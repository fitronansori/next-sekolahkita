# Rangkuman: Fetching Data di Next.js

<!-- Generated by Copilot -->

## Overview

Dokumentasi ini membahas berbagai cara untuk mengambil data di Next.js menggunakan App Router, termasuk di Server Components dan Client Components, serta implementasi streaming untuk meningkatkan performa.

## 1. Fetching Data di Server Components

### Menggunakan Fetch API

Server Components dapat dibuat menjadi asynchronous untuk mengambil data:

```tsx
export default async function Page() {
  const data = await fetch("https://api.vercel.app/blog");
  const posts = await data.json();

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

**Poin Penting:**

- Fetch responses tidak di-cache secara default
- Next.js akan melakukan prerender route dan output akan di-cache untuk performa yang lebih baik
- Untuk dynamic rendering, gunakan `{ cache: 'no-store' }`
- Saat development, fetch calls dapat di-log untuk debugging

### Menggunakan ORM atau Database

```tsx
import { db, posts } from "@/lib/db";

export default async function Page() {
  const all_posts = await db.select().from(posts);

  return (
    <ul>
      {all_posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

## 2. Fetching Data di Client Components

### Streaming Data dengan `use` Hook

**Server Component:**

```tsx
import { Suspense } from "react";

import Posts from "@/app/ui/posts";

export default function Page() {
  // Jangan await function pengambilan data
  const posts = getPosts();

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Posts posts={posts} />
    </Suspense>
  );
}
```

**Client Component:**

```tsx
"use client";

import { use } from "react";

export default function Posts({
  posts,
}: {
  posts: Promise<{ id: string; title: string }[]>;
}) {
  const all_posts = use(posts);

  return (
    <ul>
      {all_posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

### Menggunakan Community Libraries

**Dengan SWR:**

```tsx
"use client";

import useSWR from "swr";

const fetcher = (url) => fetch(url).then((r) => r.json());

export default function BlogPage() {
  const { data, error, is_loading } = useSWR(
    "https://api.vercel.app/blog",
    fetcher
  );

  if (is_loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data.map((post: { id: string; title: string }) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

## 3. Deduplicating Requests dengan React.cache

Untuk mencegah duplicate requests pada resource yang sama:

```tsx
import { cache } from "react";

import { db, eq, posts } from "@/lib/db";

export const get_post = cache(async (id: string) => {
  const post = await db.query.posts.findFirst({
    where: eq(posts.id, parseInt(id)),
  });
});
```

**Untuk Fetch API:**
Gunakan `cache: 'force-cache'` untuk mendeduplikasi requests dengan URL dan options yang sama.

## 4. Streaming

### Dengan loading.js

Buat file `loading.js` di folder yang sama dengan page untuk streaming seluruh page:

```tsx
// app/blog/loading.tsx
export default function Loading() {
  return <div>Loading...</div>;
}
```

**Cara Kerja:**

- `loading.js` akan nested di dalam `layout.js`
- Secara otomatis wrap `page.js` dan children dalam `<Suspense>` boundary
- User langsung melihat layout dan loading state saat page di-render

### Dengan `<Suspense>`

Untuk streaming yang lebih granular:

```tsx
import { Suspense } from "react";

import BlogList from "@/components/BlogList";
import BlogListSkeleton from "@/components/BlogListSkeleton";

export default function BlogPage() {
  return (
    <div>
      {/* Konten ini langsung dikirim ke client */}
      <header>
        <h1>Welcome to the Blog</h1>
        <p>Read the latest posts below.</p>
      </header>

      <main>
        {/* Konten dalam Suspense akan di-stream */}
        <Suspense fallback={<BlogListSkeleton />}>
          <BlogList />
        </Suspense>
      </main>
    </div>
  );
}
```

### Creating Meaningful Loading States

Rekomendasi untuk loading states yang baik:

- Gunakan skeletons dan spinners
- Tampilkan bagian kecil namun meaningful dari screen masa depan
- Contoh: cover photo, title, dll
- Gunakan React DevTools untuk preview dan inspect loading state saat development

## 5. Data Fetching Patterns

### Sequential Data Fetching

Terjadi ketika nested components masing-masing fetch data mereka sendiri:

```tsx
export default async function Page({
  params,
}: {
  params: Promise<{ username: string }>;
}) {
  const { username } = await params;

  // Get artist information
  const artist = await getArtist(username);

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Tampilkan fallback UI saat Playlists component loading */}
      <Suspense fallback={<div>Loading...</div>}>
        {/* Pass artist ID ke Playlists component */}
        <Playlists artist_id={artist.id} />
      </Suspense>
    </>
  );
}

async function Playlists({ artist_id }: { artist_id: string }) {
  // Gunakan artist ID untuk fetch playlists
  const playlists = await getArtistPlaylists(artist_id);

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  );
}
```

### Parallel Data Fetching

Untuk mengoptimalkan performa dengan fetch data secara paralel:

```tsx
import Albums from "./albums";

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`);
  return res.json();
}

async function getAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`);
  return res.json();
}

export default async function Page({
  params,
}: {
  params: Promise<{ username: string }>;
}) {
  const { username } = await params;

  const artist_data = getArtist(username);
  const albums_data = getAlbums(username);

  // Initiate both requests in parallel
  const [artist, albums] = await Promise.all([artist_data, albums_data]);

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  );
}
```

**Catatan:** Jika satu request gagal saat menggunakan `Promise.all`, seluruh operasi akan gagal. Untuk handling ini, gunakan `Promise.allSettled`.

### Preloading Data

Preload data dengan membuat utility function yang dipanggil sebelum blocking requests:

```tsx
import { getItem } from "@/lib/data";

export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  // Mulai loading item data
  preload(id);

  // Lakukan asynchronous task lain
  const is_available = await checkIsAvailable();

  return is_available ? <Item id={id} /> : null;
}

export const preload = (id: string) => {
  // void evaluates expression dan return undefined
  void getItem(id);
};

export async function Item({ id }: { id: string }) {
  const result = await getItem(id);
  // ...
}
```

**Dengan React cache dan server-only:**

```tsx
import { cache } from 'react'
import 'server-only'
import { getItem } from '@/lib/data'

export const preload = (id: string) => {
  void getItem(id)
}

export const getItem = cache(async (id: string) => {
  // ...
})
```

## 6. Best Practices

### Caching

- Gunakan `{ cache: 'force-cache' }` untuk cache fetch requests
- Wrap database queries dengan `React.cache()` untuk deduplication
- Leverage Next.js built-in caching untuk performa optimal

### Error Handling

- Gunakan `Promise.allSettled` untuk parallel requests yang memerlukan error handling individual
- Implement proper error boundaries untuk Client Components

### Performance

- Gunakan streaming dengan `<Suspense>` untuk better user experience
- Implement meaningful loading states
- Prioritaskan data yang penting untuk initial render

### Security

- Server Components aman untuk database queries langsung
- Hindari expose sensitive data ke Client Components
- Gunakan environment variables untuk API keys

## API Reference Terkait

- [fetch API reference](https://nextjs.org/docs/app/api-reference/functions/fetch)
- [loading.js API reference](https://nextjs.org/docs/app/api-reference/file-conventions/loading)
- [logging configuration](https://nextjs.org/docs/app/api-reference/config/next-config-js/logging)
- [Data Security guide](https://nextjs.org/docs/app/guides/data-security)
